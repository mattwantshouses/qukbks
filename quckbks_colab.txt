# Quckbks_colab Script
# Version 1.2.0

import os
import re
import pandas as pd
import csv
from google.colab import files
import datetime
import io
import chardet
import openpyxl
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.naive_bayes import MultinomialNB
from sklearn.model_selection import train_test_split

# ... (previous functions remain the same)

# 4. Transaction Classification: Enhanced classification system
def train_classifier(transactions_df):
    """
    4.1 Function: train_classifier
    Trains a Naive Bayes classifier for transaction categorization
    """
    X = transactions_df['Description']
    y = transactions_df['Category']
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
    
    vectorizer = TfidfVectorizer(stop_words='english')
    X_train_vectorized = vectorizer.fit_transform(X_train)
    
    classifier = MultinomialNB()
    classifier.fit(X_train_vectorized, y_train)
    
    return vectorizer, classifier

def classify_transactions(df, vectorizer, classifier):
    """
    4.2 Function: classify_transactions
    Classifies transactions using the trained classifier
    """
    X = df['Description']
    X_vectorized = vectorizer.transform(X)
    df['Category'] = classifier.predict(X_vectorized)
    return df

# 5. Chart of Accounts: Integration and management
class ChartOfAccounts:
    def __init__(self):
        self.accounts = {
            'Assets': {'Cash': 1000, 'Accounts Receivable': 1100},
            'Liabilities': {'Accounts Payable': 2000},
            'Equity': {'Retained Earnings': 3000},
            'Income': {'Sales': 4000},
            'Expenses': {'Office Supplies': 5000, 'Rent': 5100, 'Utilities': 5200}
        }
    
    def add_account(self, category, name, number):
        if category not in self.accounts:
            self.accounts[category] = {}
        self.accounts[category][name] = number
    
    def get_account_number(self, name):
        for category in self.accounts:
            if name in self.accounts[category]:
                return self.accounts[category][name]
        return None

# 6. Double-Entry Bookkeeping: Implementation
def process_transaction(ledger, date, description, category, account, amount):
    """
    6.1 Function: process_transaction
    Processes a transaction using double-entry bookkeeping
    """
    if amount > 0:  # Income
        ledger = ledger.append({
            'Date': date,
            'Description': description,
            'Account': account,
            'Debit': amount,
            'Credit': 0
        }, ignore_index=True)
        ledger = ledger.append({
            'Date': date,
            'Description': description,
            'Account': category,
            'Debit': 0,
            'Credit': amount
        }, ignore_index=True)
    else:  # Expense
        ledger = ledger.append({
            'Date': date,
            'Description': description,
            'Account': category,
            'Debit': abs(amount),
            'Credit': 0
        }, ignore_index=True)
        ledger = ledger.append({
            'Date': date,
            'Description': description,
            'Account': account,
            'Debit': 0,
            'Credit': abs(amount)
        }, ignore_index=True)
    return ledger

# 7. Inter-Entity Transfers: Handling transfers between entities
def inter_entity_transfer(from_entity, to_entity, amount, description):
    """
    7.1 Function: inter_entity_transfer
    Handles transfers between different entities
    """
    from_entity['ledger'] = process_transaction(
        from_entity['ledger'],
        datetime.date.today(),
        description,
        'Inter-Entity Transfer',
        'Cash',
        -amount
    )
    to_entity['ledger'] = process_transaction(
        to_entity['ledger'],
        datetime.date.today(),
        description,
        'Inter-Entity Transfer',
        'Cash',
        amount
    )

# 8. Financial Reporting: Generate comprehensive financial reports
def generate_profit_and_loss(ledger, start_date, end_date):
    """
    8.1 Function: generate_profit_and_loss
    Generates a detailed Profit and Loss statement
    """
    filtered_ledger = ledger[(ledger['Date'] >= start_date) & (ledger['Date'] <= end_date)]
    income = filtered_ledger[filtered_ledger['Account'].str.startswith('Income')]['Credit'].sum() - filtered_ledger[filtered_ledger['Account'].str.startswith('Income')]['Debit'].sum()
    expenses = filtered_ledger[filtered_ledger['Account'].str.startswith('Expenses')]['Debit'].sum() - filtered_ledger[filtered_ledger['Account'].str.startswith('Expenses')]['Credit'].sum()
    net_profit = income - expenses
    
    income_breakdown = filtered_ledger[filtered_ledger['Account'].str.startswith('Income')].groupby('Account').agg({'Credit': 'sum', 'Debit': 'sum'})
    income_breakdown['Net'] = income_breakdown['Credit'] - income_breakdown['Debit']
    
    expense_breakdown = filtered_ledger[filtered_ledger['Account'].str.startswith('Expenses')].groupby('Account').agg({'Debit': 'sum', 'Credit': 'sum'})
    expense_breakdown['Net'] = expense_breakdown['Debit'] - expense_breakdown['Credit']
    
    return {
        'Summary': pd.DataFrame({
            'Item': ['Income', 'Expenses', 'Net Profit'],
            'Amount': [income, expenses, net_profit]
        }),
        'Income Breakdown': income_breakdown,
        'Expense Breakdown': expense_breakdown
    }

def generate_balance_sheet(ledger, date):
    """
    8.2 Function: generate_balance_sheet
    Generates a Balance Sheet as of a specific date
    """
    filtered_ledger = ledger[ledger['Date'] <= date]
    
    assets = filtered_ledger[filtered_ledger['Account'].str.startswith('Assets')].groupby('Account').agg({'Debit': 'sum', 'Credit': 'sum'})
    assets['Balance'] = assets['Debit'] - assets['Credit']
    
    liabilities = filtered_ledger[filtered_ledger['Account'].str.startswith('Liabilities')].groupby('Account').agg({'Credit': 'sum', 'Debit': 'sum'})
    liabilities['Balance'] = liabilities['Credit'] - liabilities['Debit']
    
    equity = filtered_ledger[filtered_ledger['Account'].str.startswith('Equity')].groupby('Account').agg({'Credit': 'sum', 'Debit': 'sum'})
    equity['Balance'] = equity['Credit'] - equity['Debit']
    
    return {
        'Assets': assets,
        'Liabilities': liabilities,
        'Equity': equity,
        'Total Assets': assets['Balance'].sum(),
        'Total Liabilities': liabilities['Balance'].sum(),
        'Total Equity': equity['Balance'].sum()
    }

# 9. Data Export: Functions to export processed data
def export_chart_of_accounts(entity_abbr, coa):
    """
    9.1 Function: export_chart_of_accounts
    Exports the Chart of Accounts to a CSV file
    """
    coa_df = pd.DataFrame([(cat, acct, num) for cat, accounts in coa.accounts.items() for acct, num in accounts.items()],
                          columns=['Category', 'Account', 'Number'])
    coa_df.to_csv(f'{entity_abbr}_chart_of_accounts.csv', index=False)

def export_financial_reports(entity_abbr, pl_data, bs_data):
    """
    9.2 Function: export_financial_reports
    Exports the Profit and Loss statement and Balance Sheet to Excel files
    """
    with pd.ExcelWriter(f'{entity_abbr}_financial_reports.xlsx') as writer:
        pl_data['Summary'].to_excel(writer, sheet_name='P&L Summary', index=False)
        pl_data['Income Breakdown'].to_excel(writer, sheet_name='P&L Income Breakdown')
        pl_data['Expense Breakdown'].to_excel(writer, sheet_name='P&L Expense Breakdown')
        
        pd.DataFrame({'Assets': bs_data['Assets']['Balance'],
                      'Liabilities': bs_data['Liabilities']['Balance'],
                      'Equity': bs_data['Equity']['Balance']}).to_excel(writer, sheet_name='Balance Sheet')

# 10. Main Execution: Enhanced main function with improved error handling and financial analysis
def main():
    """
    10.1 Function: main
    Main execution function for the Financial Data Processor with improved error handling and financial analysis
    """
    print("Enhanced Financial Data Processor v1.2.0")
    selected_files = select_files()
    
    entities = {}
    all_transactions = pd.DataFrame()

    for file in selected_files:
        print(f"\nProcessing file: {file}")
        entity_name, entity_abbr = identify_entity(file)

        if entity_name not in entities:
            entities[entity_name] = {
                'name': entity_name,
                'abbr': entity_abbr,
                'coa': ChartOfAccounts(),
                'ledger': pd.DataFrame(columns=['Date', 'Description', 'Account', 'Debit', 'Credit']),
                'transactions': pd.DataFrame()
            }
        
        df = parse_file(file)
        if df is not None:
            try:
                all_transactions = pd.concat([all_transactions, df], ignore_index=True)
                entities[entity_name]['transactions'] = pd.concat([entities[entity_name]['transactions'], df], ignore_index=True)
                print(f"Successfully processed file. Shape: {df.shape}")
                print(df.head())
            except Exception as e:
                print(f"Error processing data for {file}: {str(e)}")

    # Train the classifier using all transactions
    vectorizer, classifier = train_classifier(all_transactions)

    for entity_name, entity_data in entities.items():
        entity_data['transactions'] = classify_transactions(entity_data['transactions'], vectorizer, classifier)
        
        # Add helper columns for analysis
        entity_data['transactions']['Month'] = pd.to_datetime(entity_data['transactions']['Date']).dt.to_period('M')
        entity_data['transactions']['Quarter'] = pd.to_datetime(entity_data['transactions']['Date']).dt.to_period('Q')
        entity_data['transactions']['Year'] = pd.to_datetime(entity_data['transactions']['Date']).dt.year
        
        # Process transactions into the ledger
        for _, row in entity_data['transactions'].iterrows():
            entity_data['ledger'] = process_transaction(
                entity_data['ledger'],
                row['Date'],
                row['Description'],
                row['Category'],
                'Cash',  # Assuming all transactions affect cash for simplicity
                row['Amount']
            )

        # Generate and export Chart of Accounts
        export_chart_of_accounts(entity_data['abbr'], entity_data['coa'])

        # Generate financial reports
        start_date = entity_data['transactions']['Date'].min()
        end_date = entity_data['transactions']['Date'].max()
        pl_data = generate_profit_and_loss(entity_data['ledger'], start_date, end_date)
        bs_data = generate_balance_sheet(entity_data['ledger'], end_date)

        # Export financial reports
        export_financial_reports(entity_data['abbr'], pl_data, bs_data)

        # Print summary of financial reports
        print(f"\nFinancial Summary for {entity_name}:")
        print("Profit and Loss Summary:")
        print(pl_data['Summary'])
        print("\nBalance Sheet Summary:")
        print(f"Total Assets: {bs_data['Total Assets']}")
        print(f"Total Liabilities: {bs_data['Total Liabilities']}")
        print(f"Total Equity: {bs_data['Total Equity']}")

    # Example of inter-entity transfer (if multiple entities exist)
    if len(entities) > 1:
        entity_names = list(entities.keys())
        inter_entity_transfer(entities[entity_names[0]], entities[entity_names[1]], 1000, "Inter-entity loan")

if __name__ == "__main__":
    main()