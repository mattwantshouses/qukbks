# Quckbks_colab Script
# Version 1.0.0

import os
import re
import pandas as pd
import csv
from google.colab import files
import datetime
import io
import chardet
import openpyxl

# 1. File Selection: Enhanced file selection with better error handling
def select_files():
    """
    1.1 Function: select_files
    Handles file selection and upload process with improved error handling
    """
    print("Available files in the Colab environment:")
    file_list = os.listdir()
    for i, file in enumerate(file_list, 1):
        print(f"{i}. {file}")
    
    while True:
        print("\nEnter file numbers to process (e.g., '1-3, 5, 7-9') or type 'upload' to add new files:")
        selection = input().lower()
        
        if selection == 'upload':
            try:
                uploaded = files.upload()
                file_list.extend(uploaded.keys())
                print("Updated file list:")
                for i, file in enumerate(file_list, 1):
                    print(f"{i}. {file}")
                continue
            except Exception as e:
                print(f"Error uploading files: {str(e)}")
                continue
        
        try:
            selected_files = []
            for part in re.split(r'[;,]\s*', selection):
                if '-' in part:
                    start, end = map(int, part.split('-'))
                    selected_files.extend(file_list[start-1:end])
                else:
                    selected_files.append(file_list[int(part)-1])
            return selected_files
        except (ValueError, IndexError):
            print("Invalid selection. Please try again.")

# 2. Entity Recognition: Improved entity recognition with custom entity support
def identify_entity(filename):
    """
    2.1 Function: identify_entity
    Identifies entity based on filename with support for custom entities
    """
    entities = {
        "Corporate1": "C1",
        "Corporate2": "C2",
        "Corporate3": "C3",
        "Personal": "P",
        "BOA": "BOA",
        "VyStar": "VS"
    }
    
    for entity, abbr in entities.items():
        if entity.lower() in filename.lower():
            return entity, abbr
    
    print(f"Unable to identify entity for {filename}.")
    print("Enter the entity name or choose from the following options:")
    for i, (entity, abbr) in enumerate(entities.items(), 1):
        print(f"{i}. {entity} ({abbr})")
    print(f"{len(entities) + 1}. Other (custom entity)")
    
    while True:
        try:
            choice = int(input("Enter your choice: "))
            if 1 <= choice <= len(entities):
                return list(entities.items())[choice - 1]
            elif choice == len(entities) + 1:
                custom_entity = input("Enter custom entity name: ")
                custom_abbr = input("Enter custom entity abbreviation: ")
                return custom_entity, custom_abbr
            else:
                print("Invalid choice. Please try again.")
        except ValueError:
            print("Invalid input. Please enter a number.")

# 3. File Parsing: Enhanced file parsing with support for various formats and encodings
def parse_file(file):
    """
    3.1 Function: parse_file
    Parses file into a DataFrame based on file type with improved format support
    """
    _, ext = os.path.splitext(file)
    
    try:
        if ext.lower() in ['.csv', '.txt']:
            # Detect file encoding
            with open(file, 'rb') as raw_file:
                encoding = chardet.detect(raw_file.read())['encoding']
            
            # Detect delimiter
            with open(file, 'r', encoding=encoding) as f:
                sample = f.read(1024)
            sniffer = csv.Sniffer()
            dialect = sniffer.sniff(sample)
            
            # Read CSV with detected encoding and delimiter
            df = pd.read_csv(file, encoding=encoding, dialect=dialect)
        elif ext.lower() in ['.xls', '.xlsx']:
            df = pd.read_excel(file, engine='openpyxl')
        else:
            raise ValueError(f"Unsupported file type: {ext}")
        
        # Flexible column detection
        required_columns = ['Date', 'Description', 'Amount']
        column_mapping = {}
        
        for required_col in required_columns:
            possible_names = [required_col] + [col for col in df.columns if required_col.lower() in col.lower()]
            for name in possible_names:
                if name in df.columns:
                    column_mapping[required_col] = name
                    break
            else:
                raise ValueError(f"Could not find a column for {required_col}")
        
        # Rename columns and select only required ones
        df = df.rename(columns=column_mapping)[required_columns]
        
        # Ensure date column is in datetime format
        df['Date'] = pd.to_datetime(df['Date'], infer_datetime_format=True, errors='coerce')
        
        # Ensure amount column is numeric
        df['Amount'] = pd.to_numeric(df['Amount'].astype(str).str.replace(r'[^\d.-]', '', regex=True), errors='coerce')
        
        return df
    
    except Exception as e:
        print(f"Error parsing file {file}: {str(e)}")
        return None

# ... (rest of the code remains the same)

# 11. Main Execution: Enhanced main function with improved error handling
def main():
    """
    11.1 Function: main
    Main execution function for the Financial Data Processor with improved error handling
    """
    print("Enhanced Financial Data Processor v1.0.0")
    selected_files = select_files()
    
    entities = {}

    for file in selected_files:
        print(f"\nProcessing file: {file}")
        entity_name, entity_abbr = identify_entity(file)

        if entity_name not in entities:
            entities[entity_name] = {
                'name': entity_name,
                'abbr': entity_abbr,
                'coa': ChartOfAccounts(),
                'ledger': pd.DataFrame(columns=['Date', 'Description', 'Account', 'Debit', 'Credit']),
                'transactions': pd.DataFrame()
            }
        
        df = parse_file(file)
        if df is not None:
            try:
                df = classify_transactions(df)
                df = add_helper_columns(df)
                entities[entity_name]['transactions'] = pd.concat([entities[entity_name]['transactions'], df], ignore_index=True)
                print(f"Successfully processed file. Shape: {df.shape}")
                print(df.head())

                # Process transactions into the ledger
                for _, row in df.iterrows():
                    entities[entity_name]['ledger'] = process_transaction(
                        entities[entity_name]['ledger'],
                        row['Date'],
                        row['Description'],
                        row['Category'],
                        'Cash',  # Assuming all transactions affect cash for simplicity
                        row['Amount']
                    )

                # Generate and export Chart of Accounts
                export_chart_of_accounts(entity_abbr, entities[entity_name]['coa'])

                # Generate and export Profit and Loss statement
                pl_df = generate_profit_and_loss(entities[entity_name]['ledger'], df['Date'].min(), df['Date'].max())
                export_profit_and_loss(entity_abbr, pl_df)

            except Exception as e:
                print(f"Error processing data for {file}: {str(e)}")

    # Example of inter-entity transfer (if multiple entities exist)
    if len(entities) > 1:
        entity_names = list(entities.keys())
        inter_entity_transfer(entities[entity_names[0]], entities[entity_names[1]], 1000, "Inter-entity loan")

if __name__ == "__main__":
    main()