# Quckbks_colab2 Script
# Version 0.1.0

import os
import re
import pandas as pd
import csv
from google.colab import files
import datetime
import io
import chardet

# 1. File Selection
def select_files():
    # 1.1 Display available files
    print("Available files in the Colab environment:")
    file_list = os.listdir()
    for i, file in enumerate(file_list, 1):
        print(f"{i}. {file}")
    
    # 1.2 User input for file selection
    print("\nEnter file numbers to process (e.g., '1-3, 5, 7-9') or type 'upload' to add new files:")
    selection = input().lower()
    
    # 1.3 File upload option
    if selection == 'upload':
        uploaded = files.upload()
        file_list.extend(uploaded.keys())
        print("Updated file list:")
        for i, file in enumerate(file_list, 1):
            print(f"{i}. {file}")
        print("\nEnter file numbers to process (e.g., '1-3, 5, 7-9'):")
        selection = input()
    
    # 1.4 Process user selection
    selected_files = []
    for part in re.split(r'[;,]\s*', selection):
        if '-' in part:
            start, end = map(int, part.split('-'))
            selected_files.extend(file_list[start-1:end])
        else:
            selected_files.append(file_list[int(part)-1])
    
    return selected_files

# 2. Entity Identification
def identify_entity(filename):
    # 2.1 Define entity mappings
    entities = {
        "Corporate1": "C1",
        "Corporate2": "C2",
        "Corporate3": "C3",
        "Personal": "P",
        "BOA": "BOA",
        "VyStar": "VS"
    }
    # 2.2 Match filename to entity
    for entity, abbr in entities.items():
        if entity.lower() in filename.lower():
            return entity, abbr
    return None, None

# 3. File Encoding Detection
def detect_encoding(file):
    # 3.1 Read file and detect encoding
    with open(file, 'rb') as f:
        raw = f.read()
    return chardet.detect(raw)['encoding']

# 4. File Parsing
def parse_file(file):
    # 4.1 Determine file type and encoding
    _, ext = os.path.splitext(file)
    encoding = detect_encoding(file)

    # 4.2 Parse CSV or TXT files
    if ext.lower() in ['.csv', '.txt']:
        with open(file, 'r', encoding=encoding) as f:
            sample = f.read(1024)
        sniffer = csv.Sniffer()
        has_header = sniffer.has_header(sample)
        dialect = sniffer.sniff(sample)
        
        df = pd.read_csv(file, dialect=dialect, encoding=encoding, header=0 if has_header else None)
    # 4.3 Parse Excel files
    elif ext.lower() in ['.xls', '.xlsx']:
        df = pd.read_excel(file)
    # 4.4 Handle PDF files (not implemented)
    elif ext.lower() == '.pdf':
        # Placeholder for PDF parsing logic
        raise NotImplementedError("PDF parsing is not yet implemented")
    # 4.5 Handle unsupported file types
    else:
        raise ValueError(f"Unsupported file type: {ext}")
    
    # 4.6 Detect and rename columns
    df = detect_and_rename_columns(df)
    
    return df

# 5. Column Detection and Renaming
def detect_and_rename_columns(df):
    # 5.1 Define column patterns
    column_patterns = {
        'Date': r'(?i)date|time',
        'Description': r'(?i)description|memo|narration',
        'Amount': r'(?i)amount|sum|total',
        'Type': r'(?i)type|category',
        'Balance': r'(?i)balance|remaining'
    }

    # 5.2 Rename columns based on patterns
    for target_col, pattern in column_patterns.items():
        matching_cols = df.columns[df.columns.str.contains(pattern, regex=True)]
        if not matching_cols.empty:
            df = df.rename(columns={matching_cols[0]: target_col})

    return df

# 6. Transaction Classification
def classify_transactions(df):
    # 6.1 Define classification function
    def classify(description, amount):
        description = description.lower()
        if 'salary' in description or 'payroll' in description:
            return 'Income:Salary'
        elif 'rent' in description:
            return 'Expense:Rent'
        elif 'grocery' in description or 'supermarket' in description:
            return 'Expense:Groceries'
        elif 'restaurant' in description or 'dining' in description:
            return 'Expense:Dining'
        elif 'transfer' in description:
            return 'Transfer'
        elif amount > 0:
            return 'Income:Other'
        else:
            return 'Expense:Other'

    # 6.2 Apply classification to dataframe
    df['Category'] = df.apply(lambda row: classify(row['Description'], row['Amount']), axis=1)
    return df

# 7. Transaction Processing
def process_transaction(ledger, date, description, debit_account, credit_account, amount):
    # 7.1 Add debit entry
    ledger = ledger.append({
        'Date': date,
        'Description': description,
        'Account': debit_account,
        'Debit': abs(amount),
        'Credit': 0
    }, ignore_index=True)
    # 7.2 Add credit entry
    ledger = ledger.append({
        'Date': date,
        'Description': description,
        'Account': credit_account,
        'Debit': 0,
        'Credit': abs(amount)
    }, ignore_index=True)
    return ledger

# 8. Helper Column Addition
def add_helper_columns(df):
    # 8.1 Flag large transactions
    df['Large Transaction'] = df['Amount'].abs() > 10000
    # 8.2 Flag transactions needing review
    df['Needs Review'] = (df['Category'] == 'Expense:Other') | (df['Category'] == 'Income:Other')
    # 8.3 Flag possible duplicates
    df['Possible Duplicate'] = df.duplicated(subset=['Date', 'Amount', 'Description'], keep=False)
    return df

# 9. Main Execution
def main():
    # 9.1 Initialize processor
    print("Enhanced Financial Data Processor v3.0")
    selected_files = select_files()
    
    entities = {}

    # 9.2 Process each selected file
    for file in selected_files:
        print(f"\nProcessing file: {file}")
        entity_name, entity_abbr = identify_entity(file)
        if entity_name is None:
            print(f"Unable to identify entity for {file}. Please enter the entity name:")
            entity_name = input()
            entity_abbr = entity_name[:2].upper()

        # 9.3 Initialize entity data structure
        if entity_name not in entities:
            entities[entity_name] = {
                'name': entity_name,
                'abbr': entity_abbr,
                'coa': ChartOfAccounts(),
                'ledger': pd.DataFrame(columns=['Date', 'Description', 'Account', 'Debit', 'Credit']),
                'transactions': pd.DataFrame()
            }
        
        # 9.4 Process file and handle errors
        try:
            df = parse_file(file)
            df = classify_transactions(df)
            df = add_helper_columns(df)
            entities[entity_name]['transactions'] = pd.concat([entities[entity_name]['transactions'], df], ignore_index=True)
            print(f"Successfully processed file. Shape: {df.shape}")
            print(df.head())

            # 9.5 Process transactions into ledger
            for _, row in df.iterrows():
                entities[entity_name]['ledger'] = process_transaction(
                    entities[entity_name]['ledger'],
                    row['Date'],
                    row['Description'],
                    row['Category'],
                    'Assets:Cash' if row['Amount'] < 0 else 'Income:Unknown',
                    abs(row['Amount'])
                )

            # 9.6 Generate and export reports
            export_chart_of_accounts(entity_abbr, entities[entity_name]['coa'])
            pl_df = generate_profit_and_loss(entities[entity_name]['ledger'], df['Date'].min(), df['Date'].max())
            export_profit_and_loss(entity_abbr, pl_df)

        except Exception as e:
            print(f"Error processing {file}: {str(e)}")
            print("Skipping this file and continuing with the next one.")
            continue

    # 9.7 Print processing summary
    print("\nProcessing complete. Summary:")
    for entity_name, entity_data in entities.items():
        print(f"\n{entity_name}:")
        print(f"Total transactions: {len(entity_data['transactions'])}")
        print(f"Date range: {entity_data['transactions']['Date'].min()} to {entity_data['transactions']['Date'].max()}")
        print(f"Total amount: {entity_data['transactions']['Amount'].sum():.2f}")

if __name__ == "__main__":
    main()